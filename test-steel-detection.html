<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é‹¼ææ–­é¢æ¤œå‡ºæ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .test-input {
            width: 100%;
            height: 100px;
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .test-button {
            background-color: #6f42c1;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        .test-button:hover {
            background-color: #5a359a;
        }
        .test-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .result {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            white-space: pre-wrap;
            font-family: monospace;
        }
        .success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        .loading {
            background-color: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }
        .steel-info {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .steel-property {
            margin: 5px 0;
            font-size: 14px;
        }
        .example-prompts {
            background-color: #e7f3ff;
            border: 1px solid #b3d9ff;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .example-prompt {
            background-color: white;
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid #ddd;
        }
        .example-prompt:hover {
            background-color: #f0f8ff;
        }
    </style>
</head>
<body>
    <h1>é‹¼ææ–­é¢æ¤œå‡ºæ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ</h1>
    
    <div class="example-prompts">
        <h3>ğŸ“ ãƒ†ã‚¹ãƒˆç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆä¾‹ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§å…¥åŠ›ï¼‰</h3>
        <div class="example-prompt" onclick="fillPrompt('1å±¤ã®æ¢ã‚’H-100Ã—100Ã—6Ã—8ã«å¤‰æ›´ã—ã¦ãã ã•ã„')">
            ã€Œ1å±¤ã®æ¢ã‚’H-100Ã—100Ã—6Ã—8ã«å¤‰æ›´ã—ã¦ãã ã•ã„ã€
        </div>
        <div class="example-prompt" onclick="fillPrompt('æŸ±ã‚’H-200Ã—200Ã—8Ã—12ã«è¨­å®šã—ã€æ¢ã‚’H-150Ã—150Ã—6Ã—9ã«ã—ã¦ãã ã•ã„')">
            ã€ŒæŸ±ã‚’H-200Ã—200Ã—8Ã—12ã«è¨­å®šã—ã€æ¢ã‚’H-150Ã—150Ã—6Ã—9ã«ã—ã¦ãã ã•ã„ã€
        </div>
        <div class="example-prompt" onclick="fillPrompt('è§’ãƒ‘ã‚¤ãƒ—â–¡100Ã—100Ã—6ã‚’ä½¿ç”¨ã—ãŸé–€å‹ãƒ©ãƒ¼ãƒ¡ãƒ³ã‚’ä½œæˆ')">
            ã€Œè§’ãƒ‘ã‚¤ãƒ—â–¡100Ã—100Ã—6ã‚’ä½¿ç”¨ã—ãŸé–€å‹ãƒ©ãƒ¼ãƒ¡ãƒ³ã‚’ä½œæˆã€
        </div>
        <div class="example-prompt" onclick="fillPrompt('å††ãƒ‘ã‚¤ãƒ—Ï†150Ã—6ã®æŸ±ã§2å±¤æ§‹é€ ã‚’ä½œæˆ')">
            ã€Œå††ãƒ‘ã‚¤ãƒ—Ï†150Ã—6ã®æŸ±ã§2å±¤æ§‹é€ ã‚’ä½œæˆã€
        </div>
        <div class="example-prompt" onclick="fillPrompt('ãƒãƒ£ãƒ³ãƒãƒ«C-200Ã—75Ã—6Ã—9ã‚’æ¢ã«ä½¿ç”¨')">
            ã€Œãƒãƒ£ãƒ³ãƒãƒ«C-200Ã—75Ã—6Ã—9ã‚’æ¢ã«ä½¿ç”¨ã€
        </div>
    </div>
    
    <div class="test-section">
        <h2>1. é‹¼ææ–­é¢æ¤œå‡ºãƒ†ã‚¹ãƒˆ</h2>
        <p>é‹¼ææ–­é¢æŒ‡å®šã‚’å«ã‚€ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ›ã—ã¦ã€æ–­é¢æ€§èƒ½ã®å–å¾—ã‚’ãƒ†ã‚¹ãƒˆã—ã¾ã™ã€‚</p>
        <textarea class="test-input" id="steelTestInput" placeholder="ä¾‹: 1å±¤ã®æ¢ã‚’H-100Ã—100Ã—6Ã—8ã«å¤‰æ›´ã—ã¦ãã ã•ã„"></textarea>
        <button class="test-button" onclick="testSteelDetection()">é‹¼ææ–­é¢æ¤œå‡ºãƒ†ã‚¹ãƒˆ</button>
        <div id="steelResult" class="result" style="display: none;"></div>
    </div>

    <div class="test-section">
        <h2>2. AIç”Ÿæˆãƒ†ã‚¹ãƒˆï¼ˆé‹¼ææ–­é¢ä»˜ãï¼‰</h2>
        <p>é‹¼ææ–­é¢æŒ‡å®šã‚’å«ã‚€ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã§AIãƒ¢ãƒ‡ãƒ«ç”Ÿæˆã‚’ãƒ†ã‚¹ãƒˆã—ã¾ã™ã€‚</p>
        <textarea class="test-input" id="aiSteelTestInput" placeholder="ä¾‹: H-100Ã—100Ã—6Ã—8ã®æ¢ã§é–€å‹ãƒ©ãƒ¼ãƒ¡ãƒ³ã‚’ä½œæˆ"></textarea>
        <button class="test-button" onclick="testAISteelGeneration()">AIç”Ÿæˆãƒ†ã‚¹ãƒˆï¼ˆé‹¼ææ–­é¢ä»˜ãï¼‰</button>
        <div id="aiSteelResult" class="result" style="display: none;"></div>
    </div>

    <div class="test-section">
        <h2>3. é‹¼æãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚¢ã‚¯ã‚»ã‚¹ãƒ†ã‚¹ãƒˆ</h2>
        <p>steel_selector.jsã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‹ãƒ†ã‚¹ãƒˆã—ã¾ã™ã€‚</p>
        <button class="test-button" onclick="testSteelLibraryAccess()">ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚¢ã‚¯ã‚»ã‚¹ãƒ†ã‚¹ãƒˆ</button>
        <div id="libraryResult" class="result" style="display: none;"></div>
    </div>

    <script>
        // steel_selector.jsã‚’èª­ã¿è¾¼ã¿
        const script = document.createElement('script');
        script.src = 'steel_selector.js';
        document.head.appendChild(script);

        // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆä¾‹ã‚’å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«è¨­å®š
        function fillPrompt(text) {
            document.getElementById('steelTestInput').value = text;
            document.getElementById('aiSteelTestInput').value = text;
        }

        // é‹¼ææ–­é¢æ¤œå‡ºãƒ†ã‚¹ãƒˆ
        async function testSteelDetection() {
            const input = document.getElementById('steelTestInput');
            const prompt = input.value.trim();
            
            if (!prompt) {
                showResult('steelResult', 'ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚', 'error');
                return;
            }

            showResult('steelResult', 'ğŸ” é‹¼ææ–­é¢ã‚’æ¤œå‡ºä¸­...', 'loading');

            try {
                // steel_selector.jsãŒèª­ã¿è¾¼ã¾ã‚Œã‚‹ã¾ã§å¾…æ©Ÿ
                if (typeof steelData === 'undefined') {
                    showResult('steelResult', 'âŒ steel_selector.jsãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚', 'error');
                    return;
                }

                const result = await detectAndFetchSteelProperties(prompt);
                
                if (result.steelData && result.steelData.length > 0) {
                    let resultText = `âœ… ${result.steelData.length}å€‹ã®é‹¼ææ–­é¢ã‚’æ¤œå‡ºã—ã¾ã—ãŸ\n\n`;
                    
                    result.steelData.forEach((steel, index) => {
                        resultText += `ã€é‹¼æ${index + 1}ã€‘: ${steel.sectionName}\n`;
                        resultText += `- æŒ‡å®šæ–­é¢: ${steel.sectionSpec}\n`;
                        resultText += `- æ–­é¢ç© A: ${steel.properties.A || 'N/A'} cmÂ²\n`;
                        resultText += `- æ–­é¢äºŒæ¬¡ãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆ Ix: ${steel.properties.Ix || 'N/A'} cmâ´\n`;
                        resultText += `- æ–­é¢äºŒæ¬¡ãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆ Iy: ${steel.properties.Iy || 'N/A'} cmâ´\n`;
                        resultText += `- æ–­é¢ä¿‚æ•° Zx: ${steel.properties.Zx || 'N/A'} cmÂ³\n`;
                        resultText += `- æ–­é¢ä¿‚æ•° Zy: ${steel.properties.Zy || 'N/A'} cmÂ³\n`;
                        resultText += `- ãƒãƒƒãƒãƒ³ã‚°ç²¾åº¦: ${(100 - steel.matchDistance).toFixed(1)}%\n\n`;
                    });
                    
                    showResult('steelResult', resultText, 'success');
                } else {
                    showResult('steelResult', 'âš ï¸ é‹¼ææ–­é¢æŒ‡å®šã¯æ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚', 'error');
                }
            } catch (error) {
                showResult('steelResult', `âŒ é‹¼ææ–­é¢æ¤œå‡ºã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:\n${error.message}`, 'error');
            }
        }

        // AIç”Ÿæˆãƒ†ã‚¹ãƒˆï¼ˆé‹¼ææ–­é¢ä»˜ãï¼‰
        async function testAISteelGeneration() {
            const input = document.getElementById('aiSteelTestInput');
            const prompt = input.value.trim();
            
            if (!prompt) {
                showResult('aiSteelResult', 'ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚', 'error');
                return;
            }

            showResult('aiSteelResult', 'ğŸ§  AIãŒãƒ¢ãƒ‡ãƒ«ã‚’ç”Ÿæˆä¸­ã§ã™...', 'loading');

            try {
                // é‹¼ææ–­é¢æ¤œå‡º
                const steelResult = await detectAndFetchSteelProperties(prompt);
                
                if (steelResult.steelData && steelResult.steelData.length > 0) {
                    showResult('aiSteelResult', `âœ… ${steelResult.steelData.length}å€‹ã®é‹¼ææ–­é¢ã‚’æ¤œå‡ºã—ã€AIç”Ÿæˆã‚’é–‹å§‹ã—ã¾ã™...`, 'loading');
                }

                // AIç”Ÿæˆãƒ†ã‚¹ãƒˆ
                const response = await fetch('/api/generate-model', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        prompt: steelResult.prompt
                    }),
                });

                if (response.ok) {
                    const data = await response.json();
                    showResult('aiSteelResult', `âœ… AIç”Ÿæˆãƒ†ã‚¹ãƒˆæˆåŠŸï¼\né‹¼ææ–­é¢æƒ…å ±ã‚’å«ã‚€ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã§ãƒ¢ãƒ‡ãƒ«ãŒç”Ÿæˆã•ã‚Œã¾ã—ãŸã€‚`, 'success');
                } else {
                    const errorData = await response.json();
                    showResult('aiSteelResult', `âŒ AIç”Ÿæˆãƒ†ã‚¹ãƒˆå¤±æ•— (${response.status}):\n${errorData.error || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                showResult('aiSteelResult', `âŒ AIç”Ÿæˆãƒ†ã‚¹ãƒˆã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:\n${error.message}`, 'error');
            }
        }

        // é‹¼æãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚¢ã‚¯ã‚»ã‚¹ãƒ†ã‚¹ãƒˆ
        function testSteelLibraryAccess() {
            showResult('libraryResult', 'ğŸ” steel_selector.jsãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚¢ã‚¯ã‚»ã‚¹ä¸­...', 'loading');

            try {
                let resultText = '=== steel_selector.jsãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚¢ã‚¯ã‚»ã‚¹ãƒ†ã‚¹ãƒˆ ===\n\n';

                // steelDataã®å­˜åœ¨ç¢ºèª
                if (typeof steelData === 'undefined') {
                    resultText += 'âŒ steelDataãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“\n';
                    showResult('libraryResult', resultText, 'error');
                    return;
                }

                resultText += 'âœ… steelDataãŒåˆ©ç”¨å¯èƒ½ã§ã™\n\n';

                // åˆ©ç”¨å¯èƒ½ãªé‹¼æã‚¿ã‚¤ãƒ—ã‚’ç¢ºèª
                const availableTypes = Object.keys(steelData);
                resultText += `ğŸ“‹ åˆ©ç”¨å¯èƒ½ãªé‹¼æã‚¿ã‚¤ãƒ— (${availableTypes.length}ç¨®é¡):\n`;
                availableTypes.forEach(type => {
                    const steel = steelData[type];
                    if (steel && steel.data) {
                        resultText += `- ${type}: ${steel.data.length}å€‹ã®æ–­é¢ãƒ‡ãƒ¼ã‚¿\n`;
                    }
                });

                resultText += '\nğŸ“Š ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ç¢ºèª:\n';
                if (availableTypes.length > 0) {
                    const firstType = availableTypes[0];
                    const firstSteel = steelData[firstType];
                    if (firstSteel && firstSteel.headers && firstSteel.data && firstSteel.data.length > 0) {
                        resultText += `- ã‚¿ã‚¤ãƒ—: ${firstType}\n`;
                        resultText += `- ãƒ˜ãƒƒãƒ€ãƒ¼æ•°: ${firstSteel.headers.length}\n`;
                        resultText += `- ãƒ‡ãƒ¼ã‚¿è¡Œæ•°: ${firstSteel.data.length}\n`;
                        resultText += `- æœ€åˆã®æ–­é¢: ${firstSteel.data[0][0]}\n`;
                    }
                }

                showResult('libraryResult', resultText, 'success');
            } catch (error) {
                showResult('libraryResult', `âŒ ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚¢ã‚¯ã‚»ã‚¹ãƒ†ã‚¹ãƒˆã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:\n${error.message}`, 'error');
            }
        }

        // çµæœè¡¨ç¤ºé–¢æ•°
        function showResult(elementId, message, type = 'success') {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = `result ${type}`;
            element.style.display = 'block';
        }

        // steel_selector.jsã®é–¢æ•°ã‚’ã‚³ãƒ”ãƒ¼ï¼ˆframe_analyzer.jsã‹ã‚‰ï¼‰
        function normalizeHeaderKey(header) {
            if (header === undefined || header === null) return '';
            return header
                .toString()
                .trim()
                .normalize('NFKC')
                .replace(/[ï¼ˆ(].*?[)ï¼‰]/g, '')
                .replace(/[\sï¼¿â€ï¼â€“â€”]/g, '')
                .replace(/[ï¼Š*Ã—âœ•âœ–]/g, 'x')
                .toLowerCase();
        }

        function normalizeKey(key) {
            return (key ?? '').toString().trim().toLowerCase();
        }

        function findRowValueByKeys(headers, normalizedHeaders, rowData, ...keys) {
            if (!Array.isArray(headers) || !Array.isArray(rowData)) return undefined;

            const normalizedTokens = keys
                .flatMap(key => {
                    if (key === undefined || key === null) return [];
                    const str = key.toString();
                    return [normalizeHeaderKey(str), normalizeKey(str)];
                })
                .filter(Boolean);

            if (normalizedTokens.length === 0) return undefined;

            const longTokens = normalizedTokens.filter(token => token.length > 1);
            const shortTokens = normalizedTokens.filter(token => token.length <= 1);

            const ensureNormalizedHeader = (index) => normalizedHeaders?.[index] ?? normalizeHeaderKey(headers[index]);

            if (longTokens.length > 0) {
                for (let index = 0; index < headers.length; index++) {
                    const normalizedHeader = ensureNormalizedHeader(index);
                    if (!normalizedHeader) continue;
                    if (longTokens.some(token => normalizedHeader.includes(token))) {
                        return rowData[index];
                    }
                }
            }

            if (shortTokens.length > 0) {
                for (let index = 0; index < headers.length; index++) {
                    const normalizedHeader = ensureNormalizedHeader(index);
                    if (!normalizedHeader) continue;
                    if (shortTokens.some(token => normalizedHeader === token)) {
                        return rowData[index];
                    }
                }
            }

            return undefined;
        }

        function getDimensionsFromRow(type, rowData, headers) {
            const dims = {};
            
            const findValue = (namePart) => {
                const name = namePart.toLowerCase();
                const index = headers.findIndex(h => h.toLowerCase().startsWith(name));
                const value = index !== -1 ? parseFloat(rowData[index]) : NaN;
                return isNaN(value) ? 0 : value;
            };
            
            try {
                switch (type) {
                    case 'hkatakou_hiro':
                    case 'hkatakou_naka':
                    case 'hkatakou_hoso':
                    case 'ikatakou':
                    case 'keiryouhkatakou':
                        const hSizes = String(rowData[0] || '0Ã—0').split('Ã—').map(v => parseFloat(v) || 0);
                        [dims.H, dims.B] = hSizes.length >= 2 ? hSizes : [0, 0];
                        dims.t1 = findValue('t1');
                        dims.t2 = findValue('t2');
                        break;
                    case 'seihoukei':
                    case 'tyouhoukei':
                        const kakuSizes = String(rowData[0] || '0Ã—0').split('Ã—').map(v => parseFloat(v) || 0);
                        [dims.A, dims.B] = kakuSizes.length >= 2 ? kakuSizes : [0, 0];
                        dims.t = findValue('t');
                        break;
                    case 'koukan':
                        dims.D = parseFloat(rowData[0]) || 0;
                        dims.t = findValue('æ¿åš');
                        break;
                }
            } catch (error) {
                console.error('Error parsing dimensions:', error);
            }
            
            return dims;
        }

        function calculateDimensionDistance(targetDims, actualDims, steelType) {
            let distance = 0;
            
            switch (steelType) {
                case 'hkatakou_hiro':
                case 'hkatakou_naka':
                case 'hkatakou_hoso':
                case 'ikatakou':
                case 'keiryouhkatakou':
                    if (targetDims.length >= 4 && actualDims.H && actualDims.B && actualDims.t1 && actualDims.t2) {
                        distance += Math.pow(targetDims[0] - actualDims.H, 2) * 2;
                        distance += Math.pow(targetDims[1] - actualDims.B, 2) * 2;
                        distance += Math.pow(targetDims[2] - actualDims.t1, 2);
                        distance += Math.pow(targetDims[3] - actualDims.t2, 2);
                    } else {
                        distance = Infinity;
                    }
                    break;
                case 'seihoukei':
                case 'tyouhoukei':
                    if (targetDims.length >= 3 && actualDims.A && actualDims.B && actualDims.t) {
                        distance += Math.pow(targetDims[0] - actualDims.A, 2) * 2;
                        distance += Math.pow(targetDims[1] - actualDims.B, 2) * 2;
                        distance += Math.pow(targetDims[2] - actualDims.t, 2);
                    } else {
                        distance = Infinity;
                    }
                    break;
                case 'koukan':
                    if (targetDims.length >= 2 && actualDims.D && actualDims.t) {
                        distance += Math.pow(targetDims[0] - actualDims.D, 2) * 3;
                        distance += Math.pow(targetDims[1] - actualDims.t, 2);
                    } else {
                        distance = Infinity;
                    }
                    break;
                default:
                    distance = Infinity;
            }
            
            return Math.sqrt(distance);
        }

        function getSteelTypeFromPattern(patternIndex) {
            const types = [
                'hkatakou_hiro',
                'hkatakou_hiro',
                'seihoukei',
                'koukan',
                'mizogatakou',
                'touhenyamakatakou'
            ];
            return types[patternIndex] || 'hkatakou_hiro';
        }

        async function detectAndFetchSteelProperties(prompt) {
            console.log('ğŸ” é‹¼ææ–­é¢æŒ‡å®šã®æ¤œå‡ºã‚’é–‹å§‹:', prompt);
            
            const steelPatterns = [
                /H-(\d+(?:\.\d+)?)\s*[Ã—x]\s*(\d+(?:\.\d+)?)\s*[Ã—x]\s*(\d+(?:\.\d+)?)\s*[Ã—x]\s*(\d+(?:\.\d+)?)/gi,
                /H(\d+(?:\.\d+)?)\s*[Ã—x]\s*(\d+(?:\.\d+)?)\s*[Ã—x]\s*(\d+(?:\.\d+)?)\s*[Ã—x]\s*(\d+(?:\.\d+)?)/gi,
                /â–¡(\d+(?:\.\d+)?)\s*[Ã—x]\s*(\d+(?:\.\d+)?)\s*[Ã—x]\s*(\d+(?:\.\d+)?)/gi,
                /Ï†(\d+(?:\.\d+)?)\s*[Ã—x]\s*(\d+(?:\.\d+)?)/gi,
                /C-(\d+(?:\.\d+)?)\s*[Ã—x]\s*(\d+(?:\.\d+)?)\s*[Ã—x]\s*(\d+(?:\.\d+)?)\s*[Ã—x]\s*(\d+(?:\.\d+)?)/gi,
                /L-(\d+(?:\.\d+)?)\s*[Ã—x]\s*(\d+(?:\.\d+)?)\s*[Ã—x]\s*(\d+(?:\.\d+)?)/gi
            ];
            
            let detectedSteels = [];
            let enhancedPrompt = prompt;
            
            steelPatterns.forEach((pattern, index) => {
                const matches = [...prompt.matchAll(pattern)];
                matches.forEach(match => {
                    const steelSpec = match[0];
                    const dimensions = match.slice(1).map(d => parseFloat(d));
                    
                    detectedSteels.push({
                        spec: steelSpec,
                        dimensions: dimensions,
                        type: getSteelTypeFromPattern(index),
                        originalMatch: match
                    });
                });
            });
            
            if (detectedSteels.length === 0) {
                return { prompt: enhancedPrompt, steelData: null };
            }
            
            const steelProperties = [];
            
            for (const steel of detectedSteels) {
                try {
                    const properties = await findSteelPropertiesFromLibrary(steel);
                    if (properties) {
                        steelProperties.push(properties);
                    }
                } catch (error) {
                    console.error('æ–­é¢æ€§èƒ½å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
                }
            }
            
            if (steelProperties.length > 0) {
                enhancedPrompt = enhancePromptWithSteelData(enhancedPrompt, steelProperties);
            }
            
            return {
                prompt: enhancedPrompt,
                steelData: steelProperties.length > 0 ? steelProperties : null
            };
        }

        async function findSteelPropertiesFromLibrary(steelInfo) {
            if (typeof steelData === 'undefined') {
                return null;
            }
            
            const steelType = steelInfo.type;
            const dimensions = steelInfo.dimensions;
            
            if (!steelData[steelType]) {
                return null;
            }
            
            const steel = steelData[steelType];
            const headers = steel.headers;
            const data = steel.data;
            
            let bestMatch = null;
            let minDistance = Infinity;
            
            for (let i = 0; i < data.length; i++) {
                const rowData = data[i];
                const rowDims = getDimensionsFromRow(steelType, rowData, headers);
                
                const distance = calculateDimensionDistance(dimensions, rowDims, steelType);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    bestMatch = {
                        index: i,
                        rowData: rowData,
                        dimensions: rowDims,
                        distance: distance
                    };
                }
            }
            
            if (!bestMatch) {
                return null;
            }
            
            const normalizedHeaders = headers.map(normalizeHeaderKey);
            const getProp = (...keys) => findRowValueByKeys(headers, normalizedHeaders, bestMatch.rowData, ...keys);
            
            const areaValue = getProp('æ–­é¢ç©', 'é¢ç©', 'A');
            const ixValue = getProp('Ix', 'å¼·è»¸æ–­é¢2æ¬¡ãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆ', 'I');
            const iyValue = getProp('Iy', 'å¼±è»¸æ–­é¢2æ¬¡ãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆ', 'I');
            const zxValue = getProp('Zx', 'å¼·è»¸æ–­é¢ä¿‚æ•°', 'Z');
            const zyValue = getProp('Zy', 'å¼±è»¸æ–­é¢ä¿‚æ•°', 'Z');
            const radiusXValue = getProp('ix', 'å¼·è»¸æ–­é¢2æ¬¡åŠå¾„', 'i');
            const radiusYValue = getProp('iy', 'å¼±è»¸æ–­é¢2æ¬¡åŠå¾„', 'i');
            
            const sectionName = bestMatch.rowData[0] ? String(bestMatch.rowData[0]) : steelInfo.spec;
            
            return {
                sectionName: sectionName,
                sectionSpec: steelInfo.spec,
                sectionType: steelType,
                dimensions: bestMatch.dimensions,
                properties: {
                    A: areaValue,
                    Ix: ixValue,
                    Iy: iyValue,
                    Zx: zxValue,
                    Zy: zyValue,
                    ix: radiusXValue,
                    iy: radiusYValue
                },
                matchDistance: bestMatch.distance
            };
        }

        function enhancePromptWithSteelData(originalPrompt, steelProperties) {
            let enhancedPrompt = originalPrompt;
            
            enhancedPrompt += '\n\n=== æŒ‡å®šã•ã‚ŒãŸé‹¼ææ–­é¢ã®è©³ç´°æƒ…å ± ===\n';
            
            steelProperties.forEach((steel, index) => {
                enhancedPrompt += `\nã€é‹¼æ${index + 1}ã€‘: ${steel.sectionName}\n`;
                enhancedPrompt += `- æŒ‡å®šæ–­é¢: ${steel.sectionSpec}\n`;
                enhancedPrompt += `- æ–­é¢ç© A: ${steel.properties.A || 'N/A'} cmÂ²\n`;
                enhancedPrompt += `- æ–­é¢äºŒæ¬¡ãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆ Ix: ${steel.properties.Ix || 'N/A'} cmâ´\n`;
                enhancedPrompt += `- æ–­é¢äºŒæ¬¡ãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆ Iy: ${steel.properties.Iy || 'N/A'} cmâ´\n`;
                enhancedPrompt += `- æ–­é¢ä¿‚æ•° Zx: ${steel.properties.Zx || 'N/A'} cmÂ³\n`;
                enhancedPrompt += `- æ–­é¢ä¿‚æ•° Zy: ${steel.properties.Zy || 'N/A'} cmÂ³\n`;
                enhancedPrompt += `- æ–­é¢äºŒæ¬¡åŠå¾„ ix: ${steel.properties.ix || 'N/A'} cm\n`;
                enhancedPrompt += `- æ–­é¢äºŒæ¬¡åŠå¾„ iy: ${steel.properties.iy || 'N/A'} cm\n`;
                
                if (steel.matchDistance < Infinity) {
                    enhancedPrompt += `- ãƒãƒƒãƒãƒ³ã‚°ç²¾åº¦: ${(100 - steel.matchDistance).toFixed(1)}%\n`;
                }
            });
            
            enhancedPrompt += '\nä¸Šè¨˜ã®æ–­é¢æ€§èƒ½å€¤ã‚’ç”¨ã„ã¦æ§‹é€ ãƒ¢ãƒ‡ãƒ«ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚\n';
            
            return enhancedPrompt;
        }
    </script>
</body>
</html>
